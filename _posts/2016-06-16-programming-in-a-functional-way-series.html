---
layout: post
title: Programming in a functional way series
date: 2016-06-16 21:32:56.000000000 +01:00
type: post
published: true
status: publish
categories: []
tags:
- 8L
- functional
meta:
_wpcom_is_markdown: '1'
_rest_api_published: '1'
_rest_api_client_id: "-1"
_publicize_job_id: '23906317441'
---
<h2>Intro</h2>
<p>It's been a great experience learning Clojure, lisp and functional style programming. This is just a short list of some principles I've learned about Functional Programming (FP) design.</p>
<h2>What you bring from your previous paradigm</h2>
<p>It's only natural to bring your previous experiences along with you when learning something new.<br />
Usually it's a positive, however coming into the FP with with my OOP background has felt at times  a hinderance.</p>
<p>Ideas such as</p>
<ul>
  <li>SOLID principle</li>
  <li>DRY</li>
  <li>Design patterns e.g. Strategy, MVC, Factory.</li>
  <li>Classes and objects</li>
  <li>Methods</li>
</ul>
<p>But not all of these were a hinderance. For example Functions are simply methods. Well that's not a 100% accurate.</p>
<p>A method is associated with an object and a function is independent of an object. Then again it depends if you're using C++ where it depends whether you're in a class.</p>
<p>I feel DRY principle can still be applied in FP, in fact DRY can probably be apply in so many parts of anyone's life outside programming.</p>
<h2>Functions as parameters</h2>
<ul>
  <li>preserve the distinction</li>
  <li>remove the duplication</li>
</ul>
<p>OOP uses interfaces to force you to program to a contract.</p>
<p>Functional version of a strategy pattern is kind of built in. You simply pass in the function that you would like to call</p>
<ul>
  <li>Function composition - they're like Lego piece</li>
  <li>
    <p>We don't care how functions work, just the input and the output</p>
  </li>
  <li>No Side effects - Given a certain input, no matter how many times that repeated function is called, the function should return the same result.</li>
  <li>Immutable values - Variables cannot be changed. Period. So really they're no longer really variables, as they don't vary. They're really constants.</li>
  <li>Higher order functions - Functions are treated as first class citizen, so they can passed in as an argument.</li>
  <li>Currying - Transforming a function that has 2 ore more arguments into a function that takes only one function.</li>
  <li>Recursion - Traditional looping</li>
  <li>Lazy Evaluation - Not processing values until the moment that you need it. An example is when you're generating a list, the result would be evaluated until called by another function.</li>
</ul>
<h2>Meanwhile in Ruby land</h2>
<h3>Side effects</h3>
{% highlight ruby %}
def square(int x)<br />
  x * x<br />
end<br />
{% endhighlight %}
<p>A small example of a function with no side effects. If x is 5, then 25 will return, every single time. It's result only depends on it's input arguments and nothing else. In addition it doesn't modify anything outside of it's scope.</p>
<p>[code lang=ruby]<br />
def processEmailMessage<br />
latest_message = Server.latest_message<br />
return process(latest_message)<br />
end<br />
[/code]</p>
<p>The method signature indicates there's no input, which is a bit deceiving. It does have an input. A hidden input, the latest message. Calling this method more than once will cause side effects. It has an effect on object(s) or variable(s) outside it's origin intended purpose.<br />
Another aspect of this function is that if we knew the inputs of this method like below then if we were to send the same latest_message object as an input parameter, then we should get the same processed message as an output.</p>
<p>[code lang=ruby]<br />
def processEmailMessage(latest_message)<br />
return process(latest_message)<br />
end<br />
[/code]</p>
<h3>Functions within functions</h3>
<p>In ruby you can do this...</p>
<p>[code lang=ruby]<br />
def my_function<br />
def returned_function<br />
end<br />
end</p>
<p>my_function</p>
<p>=&gt; :returned_function<br />
[/code]</p>
<p>a function has been declared within a function! When we call "my_function" we get a symbol back but not the function. Strange behaviour I find. I would expect to get a function back, so maybe ruby doesn't treat functions as first class citizens.</p>
<p>But what about high order functions?</p>
<h3>High order functions</h3>
<p>Simply put, when you pass functions into a function's parameter. Let's look at some examples.</p>
<p>[code lang=ruby]<br />
def name<br />
&quot;Ced&quot;<br />
end</p>
<p>def upper_case(name)<br />
name.upcase<br />
end</p>
<p>upper_case(name)<br />
[/code]</p>
<p>We passed the name function into the upper_case function and Ruby is happy to accept that. Can we do the same thing in Java?</p>
<h3>First class object</h3>
<p>Here are examples of functions as first class objects in Ruby and Java</p>
<p>[code lang=java]<br />
public String name () {<br />
return &quot;Ced&quot;;<br />
}</p>
<p>public String upperCase(name()) {<br />
return name().toUpperCase();<br />
}<br />
[/code]</p>
<p>Nope, Java doesn't accept functions as parameters, won't even compile. But is that the end of it, well not really.</p>
<p>Lets look at adding two numbers together but in a more functional way than just "a + b"..... with functions!!</p>
<p>In Java we can write the following...</p>
<p>[code lang=java]<br />
interface IAddTwoNumbers {<br />
Integer call(Integer a, Integer b);<br />
}</p>
<p>IAddTwoNumbers add_two_numbers = new IAddTwoNumbers() {<br />
public Integer call(final Integer a, final Integer b) {<br />
return a + b;<br />
}<br />
};</p>
<p>add_two_numbers.call(2, 3); //output is 5</p>
<p>[/code]</p>
<p>Here we've done something neat, we've put a function into a variable which can then later call. So whilst it's possible in Java it's possible, it's not as straightforward as in ruby.</p>
<p>[code lang=ruby]<br />
add_two_numbers = lambda { |a,b| a + b }<br />
add_two_numbers.call(2, 3) //output is 5<br />
[/code]</p>
